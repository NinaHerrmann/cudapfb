#config PLATFORM GPU CUDA
#config PROCESSES 1
#config GPUS 1
#config MODE debug

const double PI = 3.141592653589793;

struct complex {
	float x;
	float y;
};

array<float,16,dist> input;
array<float,16,dist> input_double;
array<complex,16,dist> output;
array<float,16,dist> coeff;


float init(int x){
	return (float) mkt::rand(0.0f,1.0f);
}

float zero_fill(int x){
	return (float) 0;
}

float FIR(int taps, int channels, int spectra, int Index, float a) {
	float newa = 0;
 	if (Index <= (channels * spectra)) {
 		for (int j = 0; j < taps; j++) {
			newa += input[Index+(j*channels)] * coeff[Index+(j*channels)];
		}
	}
	return newa;
}

float combine(int counter, int log2size, double pi, int Problemsize, int Index, float Ai) {
// TOBE --> (i & (1<<log2size-1-j)) ? T.get(i) + omega(j,i) * Ai : Ai + omega(j,i) * T.get(i);} 
	float newa = 0.0f;
	// Ex Omega function
	// (i & (1<<log2size-1-j))
	int b = Index / (std::pow(2, log2size-1-counter));   
	int b2 = 0;
	for (int l=0; l<=counter; l++){
	// b2 = (b & 1) ? 2*b2+1  :  2*b2;
		if (b == 1) {b2 = 2*b2+1;}
		else { b2 = 2*b2;}
		//  b >>= 1;
		b = b / (2);
	}
	// double v = 2.0 * pi/ Problemsize * (b2 << (log2size-j-1)); 
	float temp = 2.0 * pi/ Problemsize * b2 * (std::pow(2, log2size-1-counter));
	// complex intermediateresult;
	// intermediateresult.x = cos(temp);
	// intermediateresult.y = sin(temp);
	if (Index == (std::pow(2, log2size-1-counter))) {
		newa = input_double[Index] + temp * Ai;
	}
	else {
		newa = Ai + temp * input_double[Index];
	}
	return newa;
}

float fetch(int counter, int log2size, int i, float Ti){
  return input[std::pow(i,std::pow(2, log2size-1-counter))];
}

float bitrev_reorder(int log2size, int x, int i){
// brev muss verändert werden.(Bit reverse order)
	int brev = 0;
	int __powf = 0;
	return input[x / std::pow2(2,32 - log2size)];
}

main{
	int ntaps = 16;
	int nchans = 16;
	int nspectra = 16;
	input.mapInPlace(init());
	coeff.mapInPlace(init());
	input_double.mapInPlace(zero_fill());
	mkt::roi_start();
	// TODO FIR Filter
	// input.mapIndexInPlace(FIR(ntaps, nchans, nspectra));
	
    int log2size = 4; 
    input_double.mapIndexInPlace(bitrev_reorder(log2size));
	//input_double = input.mapIndex();
	for(int i = 0; i < 1; i++){
    	for (int j=0; j<log2size; j++) {
		    input_double.mapIndexInPlace(fetch(j, log2size));
		    input.mapIndexInPlace(combine(j, log2size, PI, 16)); 
	    }
	}

    mkt::roi_end();
}
